# Sneed Dedup Library

A Motoko library for efficient bi-directional mapping between Nat32 indices and arbitrary blobs, designed for Internet Computer canisters.

Sneed DAO: https://sneeddao.com
https://github.com/icsneed

Written by Snassy: https://X.com/SnassyIcp
https://github.com/snassy-icp

## Overview

Sneed Dedup provides a way to map between Nat32 indices and arbitrary blobs (Nat8 arrays) in both directions. This is particularly useful for:

- Mapping Principals to compact indices for efficient message storage
- Storing subaccounts (32-byte blobs) with numeric references
- Managing neuron IDs (32-byte blobs) with compact indices
- Any scenario requiring bi-directional mapping between blobs and numeric indices

## Features

- Bi-directional mapping between blobs and sequential Nat32 indices
- Automatic deduplication of identical blobs
- Stable storage support using Vector and Map from mops
- Two usage styles:
  - Functional style with static methods
  - Object-oriented style with class instance
- Principal-specific convenience methods
- Zero-copy state management

## Installation

1. Make sure you have [mops](https://mops.one) installed
2. Add the package to your project:

```bash
mops add sneed_dedup
```

## Usage

### Functional Style

```motoko
import Dedup "mo:sneed_dedup";

// Create empty state
let state = Dedup.empty();

// Store a blob and get its index
let blob1 = Text.encodeUtf8("Hello");
let index1 = Dedup.getOrCreateIndex(state, blob1);

// Retrieve a blob by index
let retrievedBlob = Dedup.getBlob(state, index1);

// Store a principal and get its index
let principal1 = Principal.fromText("aaaaa-aa");
let pIndex1 = Dedup.getOrCreateIndexForPrincipal(state, principal1);
```

### Object-Oriented Style

```motoko
import Dedup "mo:sneed_dedup";

// Create new instance
let dedup = Dedup.Dedup(null);

// Store a blob and get its index
let blob1 = Text.encodeUtf8("Hello");
let index1 = dedup.getOrCreateIndex(blob1);

// Retrieve a blob by index
let retrievedBlob = dedup.getBlob(index1);

// Store a principal and get its index
let principal1 = Principal.fromText("aaaaa-aa");
let pIndex1 = dedup.getOrCreateIndexForPrincipal(principal1);
```

### Canister Integration

```motoko
actor {
    // Store the DedupState directly as stable variables
    stable var blobs = Vector.new<Blob>();
    stable var blobToIndex = Map.new<Blob, Nat32>();
    
    // Create Dedup instance with current state
    var dedup = Dedup.Dedup(?{ blobs; blobToIndex });

    // No need for pre/postupgrade - the Vector and Map are already stable
}
```

## API Documentation

For detailed API documentation, see [spec/dedup.md](spec/dedup.md).

## Implementation Notes

1. The library maintains bi-directional integrity - each index maps to exactly one blob and vice versa
2. Indices are assigned sequentially starting from 0
3. The stable storage pattern ensures data persistence across upgrades
4. The stable Map provides efficient lookups and upgrade safety
5. The stable Vector ensures efficient sequential storage and upgrade safety
6. The implementation is generic, supporting any blob type, not just Principals

## Development

To run the tests:

```bash
mops test
```

## License

MIT License

## Author

Written by Snassy (2024)


If you want to start working on your project right away, you might want to try the following commands:

```bash
cd sneed_dedup/
dfx help
dfx canister --help
```

## Running the project locally

If you want to test your project locally, you can use the following commands:

```bash
# Starts the replica, running in the background
dfx start --background

# Deploys your canisters to the replica and generates your candid interface
dfx deploy
```

Once the job completes, your application will be available at `http://localhost:4943?canisterId={asset_canister_id}`.

If you have made changes to your backend canister, you can generate a new candid interface with

```bash
npm run generate
```

at any time. This is recommended before starting the frontend development server, and will be run automatically any time you run `dfx deploy`.

If you are making frontend changes, you can start a development server with

```bash
npm start
```

Which will start a server at `http://localhost:8080`, proxying API requests to the replica at port 4943.

### Note on frontend environment variables

If you are hosting frontend code somewhere without using DFX, you may need to make one of the following adjustments to ensure your project does not fetch the root key in production:

- set`DFX_NETWORK` to `ic` if you are using Webpack
- use your own preferred method to replace `process.env.DFX_NETWORK` in the autogenerated declarations
  - Setting `canisters -> {asset_canister_id} -> declarations -> env_override to a string` in `dfx.json` will replace `process.env.DFX_NETWORK` with the string in the autogenerated declarations
- Write your own `createActor` constructor
